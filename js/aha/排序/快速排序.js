/*
 * @Author: Brightness
 * @Date: 2021-09-06 15:31:02
 * @LastEditors: Brightness
 * @LastEditTime: 2021-09-06 17:00:45
 * @Description:  最常用的排序——快速排序
 */
/*
方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从
右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换它们。这里可以用两个
变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和
“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=0），指向数字 6。让哨兵 j 指向序
列的最右边（即 j=9），指向数字 8
*/
/*
    开始数字序列,以6作为基数
    i                  j
    6 1 2 7 9 3 4 5 10 8
   -----------------------
    j向左移动，寻找小于6的数字
    i                <-j
    6 1 2 7 9 3 4 5 10 8
    -----------------------
    j找到了小于6的数字5，j停下
    i             j
    6 1 2 7 9 3 4 5 10 8
    ---------------------------
    i向右移动，寻找大于6的数字
    i->             j
    6 1 2 7 9 3 4 5 10 8
    ----------------------------
    i找到了大于6的数字7，i停下
          i       j
    6 1 2 7 9 3 4 5 10 8
    -----------------------
    交换i，j所指向的数字
          i       j
    6 1 2 5 9 3 4 7 10 8
    ----------第一次交换结束------------
    j向左移动，寻找小于6的数字
          i     <-j
    6 1 2 5 9 3 4 7 10 8
    ----------------------
    j找到了小于6的数字4，j停下
          i     j
    6 1 2 5 9 3 4 7 10 8
    -----------------------
    i向右移动，寻找大于6的数字
          i->     j
    6 1 2 5 9 3 4 7 10 8
    ------------------------
    i找到了大于6的数字9，i停下
            i   j
    6 1 2 5 9 3 4 7 10 8
    ---------------------
    交换数字
            i   j
    6 1 2 5 4 3 9 7 10 8
    ---------第二次交换结束，并继续-------
    j向左移动，寻找小于6的数字，找到3
            i j
    6 1 2 5 4 3 9 7 10 8
    ------------------------
    i向右移动，寻找大于6的数字，此时i,j相遇了,指向同一个数,。说明此时“探测”结束
              i
              j
    6 1 2 5 4 3 9 7 10 8
    -----------------------
    将基准数 6 和 3 进行交换
              i
              j
    3 1 2 5 4 6 9 7 10 8
    ---------第一轮结束，此时以基准数 6 为分界点，6 左边的数都小于等于 6，6右边的数都大于等于 6--------------

    --------------将
    原来的序列，以 6 为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”，两边的的序列同上处理----------
    

 */


function fun(a = []){
    let  n = a.length-1;
        function quicksort(left, right) {
            let i, j, t, temp;
            if (left > right) {
                return;
            }
            temp = a[left]; //temp中存的就是基准数 
            i = left;
            j = right;
            while (i != j) {
                //顺序很重要，要先从右往左找
                while (a[j] >= temp && i < j) {
                    j--;
                }
                //再从左往右找 
                while (a[i] <= temp && i < j) {
                    i++;
                }
                //交换两个数在数组中的位置 
                if (i < j) //当哨兵i和哨兵j没有相遇时
                {
                    t = a[i];
                    a[i] = a[j];
                    a[j] = t;
                }
            }
            //最终将基准数归位 
            a[left]=a[i]; 
            a[i]=temp;
            quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 
            quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 
        }
        quicksort(0,n);
        return a;
}



let arr = [6,1,2,7,9,3,4,5,10,8,8];
let res = fun(arr);
//去重
function unique(arr){
    //Set数据结构，它类似于数组，其成员的值都是唯一的
    return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组
}
// res = unique(res);
console.log(res);

