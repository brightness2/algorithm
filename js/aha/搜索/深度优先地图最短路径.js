/*
 * @Author: Brightness
 * @Date: 2021-09-17 17:06:30
 * @LastEditors: Brightness
 * @LastEditTime: 2021-09-18 14:45:26
 * @Description: DFS 深度搜索解决迷宫问题
 */
/**
 * 一个迷宫，n行m列，从 (1,1),走到 (p,q),迷宫中有障碍物，找到最短路径
 */
/**
 * 1、迷宫地图可以使用二维数组表示，0表示障碍物，1表示可行走
 * 2、规定行走顺序，右，下，左，上；
 * 3、每条路结束条件，无路可走或者到达目标地点；
 */
let n = 5,m = 4;//区域行列
//地图，1表示可以走，0表示障碍物
let area = [
    [1,1,0,1],
    [1,1,1,1],
    [1,1,0,1],
    [1,0,1,1],
    [1,1,1,0],
];
//标志是否走过，0表示未走过，1表示走过
let book = [
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0],
];
let x=0,//x坐标
y=0,//y坐标
step=0;//当前步数
let p = [3,2];//要到达的点
let min = 9999;//最小步数
// 行走顺序，右，下，左，上；
let next = [
    [0,1],//向右，x+0,y+1
    [1,0],//向下,x+1,y+0
    [0,-1],//向左,x+0,y+(-1)
    [-1,0],//向上,x+(-1),y+0
]


function dfs(x,y,step){
    let tx = 0,ty = 0;
    if(x == p[0] && y == p[1]){//到达目标点
        if(step < min){
            min = step;
        }
        return;
    }

    //枚举四种走法
    for (let i = 0; i < 4; i++) {
            //计算下一个点的坐标
        tx = x+next[i][0];
        ty = y+next[i][1];

        //判断是否越界
        if(tx<0 || tx >=n || ty <0 || ty >=m){
            continue;//跳过这个方向的下一步
        }
        //判断该点不是障碍物,或者不是走过的点
        if(area[tx][ty] == 1 && book[tx][ty] == 0){
            book[tx][ty] = 1;//标记走过
            dfs(tx,ty,step+1);//开始尝试下一个点
            book[tx][ty] = 0;//尝试结束，取消标记
        }
    }
    return ;

}

dfs(x,y,step);

console.log(min);//最小步数